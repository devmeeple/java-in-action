# 자바의 신 3판

## 3장. 자바를 제대로 알려면 객체가 무엇인지를 알아야 해요

- 생성자는 객체를 생성하기 위한 유일한 도구다.
- 기본 생성자는 매개 변수가 없는 생성자를 의미한다. 기본 생성자는 자동으로 추가된다.

## 4장. 정보를 어디에 넣고 싶은데

- **변수의 종류**
    - **지역 변수(local variables)**: 메서드 중괄호 안에 선언된 변수
    - **매개 변수(parameters)**: 메서드에 전달하는 변수
    - **인스턴스 변수(instance variables)**: 메서드 밖에, 클래스 안에 선언된 변수, static을 사용하지 않는다.
    - **클래스 변수(class variables)**: 메서드 밖에, 클래스 안에 선언된 `static` 변수
- 돈 계산과 같은 정확한 계산이 요구될 때 `BigDecimal` 클래스를 사용한다.

## 7장. 배열

1. 배열을 선언할 때 대괄호를 앞 또는 뒤에 사용한다.
2. 배열의 첫 번째 위치는 `0`이다.
3. `boolean` 배열의 기본값은 `false`다.
4. `ArrayIndexOutOfBoundException` 에러는 배열 포함되지 않는 범위에 접근할 때 발생한다.
5. 중괄호를 이용하여 배열을 초기화할 때 중괄호 끝에 반드시 세미콜론을 선언해야 한다.
6. 2차원 배열을 정의할 때 대괄호를 2개 사용한다.
7. 배열을 쉽게 처리해 주는 `for`문은 `향상된 for`문이다.
8. 자바 프로그램에 데이터를 전달해 주려면 클래스 이름뒤에 공백을 구분하여 나열한다.
9. 자바 프로그램이 시작할 때 전달받은 내용은 `String` 타입 배열이다.

## 8장. 참조형

- 기본형을 제외한 모든 자료형은 참조형이다.
- **인스턴스 변수와 클래스 변수**
- 생성자는 객체를 생성하기 위해서 존재한다.
- 오버로딩(Overloading)이란 메서드 이름은 같지만, 매개변수의 개수, 타입 또는 순서가 다른 여러 메서드를 정의하는 방법이다. `System.out.println()`이 대표적인 예다.
    - 같은 역할을 하는 메서드는 같은 메서드 이름을 갖는다.
- `static`은 모든 객체에서 하나의 값을 사용한다.

1. 생성자를 추가로 정의하지 않으면 기본 생성자는 자동으로 생성된다.
2. 매개 변수가 있는 생성자를 만들었다면, 기본 생성자를 만들어야 호출할 수 있다.
3. 생성자의 개수 제한은 없다.
4. `this` 키워드를 사용하여 멤버 변수와 매개 변수의 차이를 구분한다.
5. `return` 키워드를 사용하여 결과를 반환한다.
6. 값을 반환하고 싶지 않을 때 `void`를 사용한다.
7. `static` 메서드는 사용할 때 객체를 선언하지 않아도 사용할 수 있다.
8. 오버로딩(Overloading)은 메서드 이름은 같지만 매개 변수를 달리하여 사용한다.
9. 기본형을 매개 변수로 넘겨줄 때는 값을 전달(Pass by value)한다.
10. 참조형을 매개 변수로 념겨줄 때 주소값을 전달한다.
11. 매개 변수의 수가 가변적일 때 타입과 변수 이름 사이에 `...`을 사용한다.

## 21. 실수를 방지하기 위한 제네릭이라는 것도 있어요

1. 제네릭은 형변환 과정에서 발생할 수 있는 런타임 오류를 컴파일 시점에 미리 방지하기 위해 Java 5에서 도입됐다.
2. 제네릭 타입 매개변수에 사용하는 문자는 어떤 알파벳이든 가능하다. 하지만 의미를 명확하게 하기 위한 관례 규칙은 있다. (`T`(Type), `E`(Element), `K`(Key), `V`(Value) 등)
3. 메서드의 제네릭 타입을 명시적으로 지정하기 애매할 때는 `?`(Wildcards)를 사용한다.
4. `? extends 클래스`(Bounded Wildcards)는 지정한 클래스 또는 하위 타입만 허용하는 상한 제한(upper bound) 와일드카드다.
5. 와일드카드를 사용하면 값을 읽는 것은 가능하지만, 값을 쓰는 것은 불가능하다는 제약이 있다. (*즉, 읽기 전용(read-only)으로 동작한다.)
6. 메서드를 제네릭하게 선언하려면 반환 타입 앞에 제네릭 타입 매개변수를 선언해야 한다.

## 22. 자바랭 다음으로 많이 쓰는 애들은 컬렉션(List)

1. `List`, `Queue`, `Set`은 `Collection` 인터페이스를 구현한 대표적인 자료구조다.
2. `List`는 저장 순서를 유지하는 순서 있는 자료구조다.
3. `ArrayList`를 기본 생성자로 생성하면 초기 크기 10을 할당된다.
4. `ArrayList(int initialCapacity)` 생성자를 사용하면 초기 크기를 직접 설정할 수 있다.
5. 제네릭을 사용하면 컬렉션에 지정된 타입만 저장할 수 있어 타입 안정성을 확보하고 형변환 오류를 방지한다.
6. `ArrayList`의 `add` 메서드는 단일 요소를, `addAll` 메서드는 다른 컬렉션의 모든 요소를 추가한다.
7. 향상된 `for`(`for-each`)문은 `Iterable` 인터페이스를 구현한 객체에서 사용할 수 있다.
8. `size`를 사용하면 컬렉션을 구현한 객체의 크기를 알 수 있다.
9. `get(int index)`는 특정 위치에 있는 데이터를 확인한다.
10. `remove(int index)`를 사용하면 특정 위치에 있는 데이터를 삭제한다.
11. `set(int index, E element)`는 특정 위치에 있는 데이터를 수정한다.
12. `Stack`은 `Vector` 클래스를 상속한 후입선출(LIFO) 구조의 자료구조다.
13. `Stack`의 데이터를 추가하는 메서드는 `push(E item)`다.
14. `peek` 메서드는 가장 위에 있는 데이터를 조회만 한다.
15. `pop` 메서드는 데이터를 삭제하고 반환한다.

## 23. 자바랭 다음으로 많이 쓰는 애들은 컬렉션(Set과 Queue)

1. `Set`은 중복을 허용하지 않고, 순서가 중요하지 않은 데이터를 하나의 객체에 저장할 때 사용한다.
2. `HashSet(int initialCapacity)` 생성자는 초기 해쉬 테이블의 크기를 지정한다.
3. `add(E e)`는 `HashSet`의 데이터를 추가한다.
4. `contains(Object o)`는 특정 데이터가 존재하는지 확인한다.
5. `remove(Object o)`는 특정 데이터를 삭제한다.
6. FIFO는 First In First Out, 선입선출을 의미한다. 먼저 들어온 데이터가 가장 먼저 나간다.
7. `Deque`는 Double Ended Queue의 약어다. 양쪽(앞뒤)에서 데이터 삽입과 삭제가 모두 가능한 자료구조다.
8. `LikedList`는 이중 연결 리스트로, 삽입·삭제는 빠르지만 인덱스 접근은 느리다. 더불어 `List`, `Queue`, `Deque`로 모두 활용 가능하다.

## 24. 자바랭 다음으로 많이 쓰는 애들은 컬렉션(Map)

1. `Map`은 `key-value`(키-값) 형태로 데이터를 저장한다. 각 키는 유일해야 하며, 중복 키는 허용하지 않는다. 동일한 키로 데이터를 저장하면 기존값을 덮어쓴다.
2. 데이터를 저장하는 메서드는 `put(K key, V value)`이다.
3. 특정 키에 해당하는 값을 가져오는 메서드는 `get(Object key)`다.
4. 특정 키와 연결된 데이터를 지우는 메서드는 `remove(Object key)`다.
5. `keySet()`을 통해 모든 키를 `Set<K>` 형태로 반환한다.
6. `size()`는 현재 `Map`에 저장된 `key-value` 쌍 개수를 반환한다.
7. `HashMap`은 키와 값 모두 `null`을 허용한다.
    - `null`을 허용하지 않던 이전 구현체 `Hashtable`과 달리 `null`키는 내부적으로 배열의 첫 번째 버킷(인덱스 0)에 저장된다.
    - `null`키를 기본값(default value)으로 저장하는 용도로 사용하는 등, 편의성을 높였다.
8. `Hashtable`은 스레드 안전(thread-safety) 하다. 내부의 모든 메서드가 `synchronized` 처리되어, 여러 스레드가 동시에 접근해도 안전하지만 성능이 느리다.
9. `containsKey(Object key)`는 특정 키가 존재하는지 확인하는 메서드다.
10. `TreeMap`은 키를 오름차순(기본 정렬)에 따라 정렬하여 저장한다.
11. `Properties`는 `Hashtable<Object, Object>`을 상속한 클래스다. 주로 설정 파일을 읽고 쓰는 용도로 사용한다.
12. `store(OutputStream out, string comments)`메서드는 `Properties` 객체에 저장된 데이터를 파일로 내보낼 때 사용한다.

## 25. 쓰레드는 개발자라면 알아두는 것이 좋아요

### 스레드의 기본 개념 및 구현

1. 프로세스는 실행 중인 프로그램 단위이며 운영체제로부터 독립적인 자원을 할당받는다. 하지만 스레드는 프로세스 내부에 생성되어 프로세스 자원을 공유한다. 즉, 프로세스는 실행 단위다.
2. `Runnable` 인터페이스를 구현하면 스레드를 정의할 수 있다. 자바의 단일 상속 한계를 극복하기 위한 방법이다.
3. `Runnable` 인터페이스를 구현하거나, `Thread` 클래스를 상속할 때, 스레드가 수행할 작업을 정의하는 `run` 메서드는 반드시 오버라이드(Override) 해야 한다.
4. `Thread` 클래스를 상속하면 스레드를 정의할 수 있다. 하지만 이미 다른 클래스를 상속하고 있다면 사용할 수 없으므로 `Runnable` 구현이 유연한 방법이다.
5. `run`은 실제 작업을 시작하는 진입점 메서드다.
6. `start`는 스레드가 실행될 수 있는 상태로 만들고 JVM 스케줄러에게 실행 요청을 지시하는 메서드다.

### 스레드 제어 및 동기화

7. `Thread.sleep(long mills)`는 `static` 메서드이며, 현재 실행 중인 스레드를 지정된 시간 동안 일시 중지(Timed Waiting 상태) 시키는 역할이다.
8. `sleep` 메서드는 스레드가 일시 중지된 동안 외부에서 `interrupt`를 호출하여 잠에서 깨울 수 있다. 이때 `InterruptedException`이 발생하며, 이를 처리하기 위해
   `try-catch` 구문이 반드시 필요하다.
9. 데몬 스레드는(Daemon Thread)는 사용자 스레드를 보조하는 백그라운드 스레드다. 모든 사용자 스레드가 종료되면 데몬 스레드는 강제로 자동 종료된다.
10. `synchronized`는 메서드 전체 또는 특정 블록에 사용한다. 멀티스레드 환경에서 공유 자원에 동시 접근을 막아 데이터의 일관성을 유지하기 위해 사용한다.
11. `synchronized`는 메서드 또는 블록을 만들어 사용한다.
12. 스레드의 주요 상태는 다음과 같다. New(생성되었지만 호출되지 않음), Runnable(실행 가능), Terminated(종료), Blocked, Waiting, Timed Waiting(대기)

### 스레드 협력 및 제어

13. `join`은 특정 스레드가 작업을 완료할 때까지 현재 실행 중인 스레드를 기다리게 하는 실행 순서 제어 메서드다.
14. `interrupt`는 스레드에게 중단 요청 신호를 보낸다.
15. `interrupt`는 스레드가 일시 정지(대기) 상태에 있을 때 효과를 발휘한다.
16. `wait`은 현재 스레드를 특정 객체(모니터)의 대기 집합에 넣어 무한정 대기 상태를 만든다. `notify`를 호출해야 대기 상태에 깨어난다.
17. `notify`는 `wait` 중인 스레드 중 하나를 깨워 실행 가능 상태(Runnable)로 만든다.
18. `Thread.enumerate(Thread[] tarray)`는 현재 활성화되어 있는 모든 스레드를 지정된 배열로 복사하여 가져온다. 현재 JVM 내의 실행 중인 스레드의 목록과 수를 확인하는 용도로
    사용한다.

### 참고 자료

- [자바는 Call By Value(Pass By Value) 방식으로만 동작한다](https://mangkyu.tistory.com/322)
