# 헤드퍼스트 자바 3판

## 2. 클래스와 객체

> 자바 클래스를 설계할 때 가장 근본적으로 고려해야 할 것은 무엇일까요?

- 클래스 설계시 클래스의 역할, 책임, 협력에 대해 고민해야 한다.

> 클래스를 설계할 때 사용할 체크 목록을 만든다면 어떤 내용을 포함하는 것이 좋을까요?

- 클래스를 설계할 때 포함할 수 있는 체크 목록
    - 책임 및 응집도(단일 책임 원칙 준수 여부)
    - 정보 은닉(캡슐화)
    - 협력 및 유연성(인터페이스 의존)
    - 재사용성(상속 및 구성)
    - 명명 규칙(일관된 명명 사용 여부)
    - 테스트 용이성

### 프로시저와 메서드

**프로시저(Procedure)**

- 프로시저는 C나 파스칼 같은 초기 절차 지향 언어에서 주로 사용하던 용어다.
- 작업을 순서(절차)대로 처리하는 것에 중점을 둔다.

**메서드(Method)**

- 메서드는 객체 지향 언어에서 사용하는 용어다.
- 메서드는 객체가 수행하는 동작이며, 객체의 상태를 변경하거나 객체와 관련된 연산 수행에 중점을 둔다.

- 오버라이딩은 하위 클래스에서 상위 클래스 메서드의 역할을 변경하거나 확장할 때 상속받은 메서드를 재정의하다.
- 자바 클래스를 설계할 때 가장 근본적으로 고려해야 할 것은 무엇일까요?
- 클래스를 설계할 때 사용할 체크 목록을 만든다면 어떤 내용을 포함하는 것이 좋을까요?

### Heap

- 힙(Heap) 메모리는 프로그래밍에서 동적으로 할당되는 메모리 영역을 의미한다.
- 힙에 할당된 메모리는 명시적으로 해제하거나 가비지 컬렉션(Garbage Collection)이 실행될 때까지 유지된다.

**Garbage-Collectible Heap**

- 자바의 힙은 특별하게 가비지 컬렉터블 힙(Garbage-Collectible Heap)이라 부른다.
- 일반적인 동적 할당 메모리 힙과 달리 자바 가상 머신(JVM)이 메모리 해제 작업을 자동으로 관리한다.

### 무엇이든 물어보세요

**자바의 전역 개념**

- 자바는 C/C++처럼 코드 전체에 접근 가능한 전역 변수, 전역 함수 개념이 없다. 모든 데이터와 동작은 클래스에 캡슐화되어야 한다.
- `public`과 `static`키워드를 조합하여 이와 비슷한 기능을 구현한다.
  - `static`: 변수와 메서드가 인스턴스(객체)에 속하지 않고, 클래스 자체에 속한다. 객체를 생성하지 않고 `클래스이름.변수`, `클래스이름.메서드()` 형태로 접근한다.
  - `public`: 변수나 메서드를 모든 클래스에서 접근할 수 있도 록한다.

**인스톨러 프로그램(JRE Bundle)**

- 사용자 PC에 JVM이 없거나 버전이 달라도 프로그램이 정상 실행할 수 있도록 도와준다.
- `exe`, `dmg`등 OS에 맞는 설치 파일로 만든다.
- 빌드 도구(gradle, maven)는 JAR를 만들고 인스톨러는 JAR + JVM을 패키 징한다.

- 클래스를 다양한 JVM과 함께 묶어 주는 인스톨러 프로그램

## 3. 원시 변수와 레퍼런스

- 원시형(기본형)은 실제 값을 대입하고, 레퍼런스(참조형)는 주소값을 대입한다.
- 참조 대상이 없는 변수는 가비지 컬렉션(GC: Garbage Collection) 대상이 된다.
- 배열은 내용과 상관없이 언제나 객체다.

## 4. 객체의 행동 방식

### 접근자와 변경자

- 게터(Getter)는 인스턴스 변수의 값을 읽는 메서드다. 정식 명칭은 접근자(Accessor)다.
- 세터(Setter)는 인스턴스 변수의 값을 변경하는 메서드다. 정식 명칭은 변경자(Mutator)다.

### 캡슐화(Encapsulation)

- 캡슐화는 객체의 데이터(인스턴스 변수)와 데이터를 다루는 메서드를 하나로 묶고, 외부에서 데이터에 직접 겁근하는 것을 막아 정보를 보호하는 객체 지향의 핵심 원칙이다.
- 인스턴스 변수는 `private` 접근 제한자를 사용한다.
- 객체의 데이터를 변경하려면 반드시 `public`으로 선언된 세터 메서드와 같은 공개 메서드를 사용하도록 강제한다.
    - 객체 스스로 자신의 상태를 관리하도록 한다.
- 인스턴스 변수가 직접 노출되면 외부에서 변수에 어떤 값이든 제한 없이 직접 대입할 수 있다.
- 세터 메서드를 사용하면 값을 대입하기 전에 유효성 검사나 특정 로직을 추가하는 등 원하는 구현이 가능하다.
- 캡슐화의 가장 큰 장점은 유연성과 유지보수성이다.
- 객체의 내부 구현이 변경되더라도, 외부에 공개된 접근자/변경자 메서드의 시그니처가 유지되면 객체를 사용하는 클라이언트는 영향받지 않는다.
  - 결합도(Coupling)를 낮추고 코드 변경에 용이하게 만든다.

### 변수의 초기화

- 클래스 내부에 선언하는 인스턴스 변수는 자동으로 초기값이 대입된다.
- 메서드 내부에 선언하는 지역 변수는 반드시 사용 전 초기화가 필요하다.

### 객체의 동치(Equality)

- 객체의 동치는 개발자가 어떻게 정의하는지에 따라 달라진다.
- 동일성(Identity): 같은 메모리 주소를 참조하는지, 완전히 동일한 객체인지 판단한다. `==` 연산자 사용
- 동등성(Equality): 객체가 논리적으로 같은 값을 가지고 있는지 판단한다. `equals()` 메서드 사용

## 5. 프로그램 만들기

- 반복 조건이 명확할 때는 `for`문 사용을 권장, 명확하지 않을 때는 `while`문을 권장한다.

### 난수 생성하기

**Math.random()**

```java
// 0.0 이상 1.0 미만의 double 난수
double radomDouble = Math.random();

// 1부터 10까지의 정수 난수
int randomInt = (int) (Math.random() * 10) + 1;
```

- `Math.random()`은 자바 초기 버전 부터 사용하던 정적 메서드
- `0.0`(포함) 이상 `1.0`(제외) 미만의 `double` 타입 난수를 반환한다.

**java.util.Random 클래스**

```java
Random random = new Random();

// 0~99 까지의 난수
int randomInt = random.nextInt(100);

// 0.0 이상 1.0 미만 난수
double randomDouble = random.nextDouble();
```

- `Math.random()` 메서드보다 다양하고 유연한 난수 생성 기능을 제공
- `nextInt()`, `nextDouble()` 등 다양한 타입의 난수를 생성하는 메서드 지원 

**정리**

- `Random` 클래스는 난수 생성 로직의 스레드 안정성(Thread Safety)을 보장한다. 하지만 안정성을 확보하는 방법 때문에 멀티 스레드 환경에서는 성능 문제가 발생한다.
- 멀티 스레드 환경에서는 `ThreadLocalRandom`을 사용한다. `Random` 클래스의 동기화 오버헤드 문제를 해결하기 위해 JDK 7에 도입됐다.
